---
title: 设计模式之装饰者模式
tags:
  - Java
  - 设计模式
date: 2020-02-25 12:16:00
---

**装饰者模式**动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

1. #### 本模式需要解决的问题

咖啡店有各种饮品，每个饮品都有它的描述和价格，同时，还有各种调料可以组合到已有的饮品中。
{% asset_img 需求描述.png 需求描述 %}
<!--more-->

2. #### 未应用设计模式前

```java
/**
 * 原场景下
 * 咖啡店的饮料类
 * 每种饮料都会创建一个类，每个cost()方法计算出咖啡和订单上各种调料的价钱,形成"类爆炸"
 * 如果在Beverage基类中加入新功能，并不适用于所有的子类
 */
public class DecoratorPatternWithout {
    public static void main(String[] args) {
        Beverage beverage = new HouseBlend();
        System.out.println("HouseBlend cost :" + beverage.cost());
    }
}

abstract class Beverage {
    String description = "unknown beverage";

    public String getDescription() {
        return description;
    }

    public abstract float cost();
}

class HouseBlend extends Beverage {

    String milkPrice = "$2";

    @Override
    public float cost() {
        System.out.println(HouseBlend.class.toGenericString() + " costs $10 ");
        return 10.0f;
    }
}

class DarkBlend extends Beverage {

    @Override
    public float cost() {
        System.out.println(DarkBlend.class.toGenericString() + " costs $11");
        return 11.0f;
    }
}

class Decaf extends Beverage {

    @Override
    public float cost() {
        System.out.println(Decaf.class.toGenericString() + " costs $12");
        return 12.0f;
    }
}
```

**缺点：**
- 每种饮料都会创建一个类，每个cost()方法计算出咖啡和订单上各种调料的价钱,形成"类爆炸"
- 如果在Beverage基类中加入新功能，并不适用于所有的子类

3. #### 应用装饰者模式后

    > 具体的处理方案是
    1. 拿一个DarkRoast对象
    2. 以Mocha对象装饰它
    3. 以Whip对象装饰它
    4. 调用cost()方法，并依赖委托(delegate)将调料的价格加上去

```java
/**
 * 装饰者模式：动态的将责任附加到对象上。
 * 若要扩展功能，装饰者提供了比继承更有弹性的替代方案
 */
public class DecoratorPattern {
    public static void main(String[] args) {
        Beverage beverage = new DarkRoast();
        beverage = new Mocha(beverage);
        beverage = new Whip(beverage);
        System.out.println("total description:" + beverage.getDescription());
        System.out.println("total cost:" + beverage.cost());
    }
}

class DarkRoast extends Beverage {

    public DarkRoast(){
        description = "darkRoast";
    }
    @Override
    public float cost() {
        System.out.println(DarkRoast.class.toGenericString() + " cost $5");
        return 5;
    }
}

abstract class CondimentDecorator extends Beverage {

    public abstract String getDescription();

    @Override
    public float cost() {
        return 0;
    }
}

class Mocha extends CondimentDecorator {

    Beverage beverage;

    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return "mocha decorator," + beverage.getDescription();
    }

    @Override
    public float cost() {
        System.out.println(Mocha.class.toGenericString() + " cost $6 extra");
        return 6 + beverage.cost();
    }
}

class Whip extends CondimentDecorator {
    Beverage beverage;

    public Whip(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return "whip decorator," + beverage.getDescription();
    }

    @Override
    public float cost() {
        System.out.println(Whip.class.toGenericString() + " cost $7 extra");
        return 7 + beverage.cost();
    }
}
```

**优点:**
- 修改调料制作一种新饮料时，只要装配一个新的组合就可以了